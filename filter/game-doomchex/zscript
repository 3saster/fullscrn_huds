version "4.1.2"

Class SpecialDoomStatusBar : DoomStatusBar
{
	transient CVar splitHUD;
	transient CVar alphaValue;
	transient CVar alphaOpaque;
	
	transient CVAR boomColors;
	transient CVAR splitArms;
	transient CVAR invReplace;
	transient CVAR berserkShow;
	transient CVAR chexArms;
	transient CVAR automapHide;
	
	transient CVAR statsType;
	transient CVAR statsCompColor;
	transient CVAR statKills;
	transient CVAR statSecrets;
	transient CVAR statItems;
	transient CVAR statTime;
	
	InventoryBarState diparms_sbar;
	HUDFont mIndexFontF; // For Chex

	enum StatsTypeValues
	{
		DISABLED = 0,
		PERCENT = 1,
		COUNTDOWN = 2,
		FRACTION = 3
	}
	
	enum StatsColorValues
	{
		GREEN = 0,
		RED = 1,
		NONE = 2,
	}
	
	enum StatsPosition
	{
		OFF = 0,
		TOPLEFT = 1,
		TOPRIGHT = 2,
		BOTTOMLEFT = 3,
		BOTTOMRIGHT = 4
	}
	
	enum OpaqueValues
	{
		OP_NONE = 0,
		OP_NUM = 1,
		OP_NUMGRAPH = 2,
	}
	
	override void Init()
	{
		Super.Init();
		
		splitHUD    = CVar.FindCVar("fullhud_split");
		alphaValue  = CVar.FindCVar("fullhud_trans");
		alphaOpaque = CVar.FindCVar("fullhud_opaque");
		
		boomColors  = CVar.FindCVar("fullhud_boomcolors");
		splitArms   = CVar.FindCVar("fullhud_splitarms");
		invReplace  = CVar.FindCVar("fullhud_invovermug");
		berserkShow = CVar.FindCVar("fullhud_showberserk");
		chexArms    = CVar.FindCVar("fullhud_chexarms");
		automapHide = CVar.FindCVar("fullhud_automaphide");
		
		statsType      = CVar.FindCVar("fullhud_stats_type");
		statsCompColor = CVar.FindCVar("fullhud_stats_comp");
		statKills      = CVar.FindCVar("fullhud_stats_kills");
		statSecrets    = CVar.FindCVar("fullhud_stats_secrets");
		statItems      = CVar.FindCVar("fullhud_stats_items");
		statTime       = CVar.FindCVar("fullhud_stats_time");

		diparms_sbar = InventoryBarState.CreateNoBox(mIndexFont, boxsize:(31, 31), arrowoffs:(0,-10));
		
		mIndexFontF = mIndexFont;
		// Chex has a really weird font
		if(isChex())
		{
			Font fnt = "HUDFONT_DOOM";
			mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellCenter, 0, 0);
			
			fnt = "INDEXFONT_CHEX";
			mIndexFontF = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);
		}
	}

	override void Draw (int state, double TicFrac)
	{
		BaseStatusBar.Draw (state, TicFrac);

		if (state == HUD_StatusBar)
		{
			if(!(automapactive && automapHide.GetInt()))
			{
				SetSize(32, 320, 200);
				BeginStatusBar();
				if(!automapactive) DrawLevelStats (NewConsoleFont);
				DrawMainBar (TicFrac);
			}
			else // Hide HUD on Automap
				SetSize(0, 320, 200);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawLevelStats (NewConsoleFont);
			DrawFullScreenStuff();
		}
	}

	protected void DrawFullScreenStuff ()
	{
		if(splitHUD.getint())
			DrawSplit();
		else
			DrawUnsplit();
	}
	
	// =====================================================
	// The Main Functions for Drawing Split and Unsplit HUDS
	// =====================================================
	void DrawUnsplit ()
	{
		double alphaFloat = 1-alphaValue.getfloat(); // Transparency
		
		int alphaO = alphaOpaque.GetInt();
		double alphaFloatNum = alphaO == OP_NUM || alphaO == OP_NUMGRAPH ? 1 : alphaFloat;
		double alphaFloatGraph = alphaO == OP_NUMGRAPH ? 1 : alphaFloat;
		
		// Draw Main STBAR Chunk
		if(multiplayer)
		{
			if(deathmatch || teamplay)
			{
				DrawImage(addArms("HUD_DM"), (0, 0), DI_SCREEN_CENTER_BOTTOM, alphaFloat);
			}
			else
			{
				DrawImage(addArms("HUD_SMP"), (0, 0), DI_SCREEN_CENTER_BOTTOM, alphaFloat);
			}
			DrawImage("STFBANY", (-17, -32), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS|DI_TRANSLATABLE, alphaFloat);
		}
		else
		{
			DrawImage(addArms("HUD_SMP"), (0, 0), DI_SCREEN_CENTER_BOTTOM, alphaFloat);
		}
		
		// Draw Percent Symbols
		int percentColor = GetPercentColor();
		DrawString(mHUDFont, "%", (-70+isChex(1), -29), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_TOP|DI_NOSHADOW, translation: percentColor, alpha:alphaFloatNum);
		DrawString(mHUDFont, "%", (61+isChex(2),  -29), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_TOP|DI_NOSHADOW, translation: percentColor, alpha:alphaFloatNum);
		
		// Draw Current Ammo Counter
		Inventory a1 = GetCurrentAmmo();
		if (a1 != null)
		{
			int ammoColor = GetAmmoColor(a1);
			DrawString(mHUDFont, FormatNumber(a1.Amount, 3), (-116+isChex(4), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_CENTER_BOTTOM, translation: ammoColor, alpha:alphaFloatNum);
		}
		
		// Draw Health
		int healthColor = GetHealthColor();
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 3), (-70+isChex(1), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_CENTER_BOTTOM, translation: healthColor, alpha:alphaFloatNum);
		
		// Draw Armor
		int armorColor = GetArmorColor();
		DrawString(mHUDFont, FormatNumber(GetArmorAmount(), 3), (61+isChex(2), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_CENTER_BOTTOM, translation:armorColor, alpha:alphaFloatNum);

		// Draw Keys
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		//  key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		DrawImage(image, (79, -29), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
		//  key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		DrawImage(image, (79, -19), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
		//  key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		DrawImage(image, (79, -9), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
		
		// Draw Total Ammo Count
		int amt1, maxamt;
		string ammonamesDoom[4] = {"Clip","Shell","RocketAmmo","Cell"};
		string ammonamesHacx[4] = {"HacxRounds","HacxCartridges","HacxTorpedo","HacxMolecules"};
		
		if(!chexArms || chexArms.getInt())
		{
			for(int i = 0; i < 4; i++)
			{
				for(int j = 0; j < AllActorClasses.Size(); j++)
				{
					if(AllActorClasses[j] is (!isHacx() ? ammonamesDoom[i] : ammonamesHacx[i]) )
					{
						let ammotype = (class<Ammo>)(AllActorClasses[j]);
						[amt1, maxamt] = GetAmount(ammotype);
						DrawString(mIndexFontF, FormatNumber(amt1,   3), (128+isChex(5), -27+6*i), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_CENTER_BOTTOM, alpha:alphaFloatNum);
						DrawString(mIndexFontF, FormatNumber(maxamt, 3), (154+isChex(1), -27+6*i), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_CENTER_BOTTOM, alpha:alphaFloatNum);
						break;
					}			
				}
			}
		}
		
		// Draw Frags
		if (deathmatch || teamplay)
		{
			DrawString(mHUDFont, FormatNumber(CPlayer.FragCount, 3), (-22+isChex(3), -29), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_CENTER_BOTTOM|DI_NOSHADOW, alpha:alphaFloatNum);
		}
		// Draw Arms
		else if(!chexArms || chexArms.getInt())
		{
			DrawImage(CPlayer.HasWeaponsInSlot(2)? chexName("STYSNUM2") : chexName("STGNUM2"), (-49, -28), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			DrawImage(CPlayer.HasWeaponsInSlot(3)? chexName("STYSNUM3") : chexName("STGNUM3"), (-37, -28), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			DrawImage(CPlayer.HasWeaponsInSlot(4)? chexName("STYSNUM4") : chexName("STGNUM4"), (-25, -28), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			DrawImage(CPlayer.HasWeaponsInSlot(5)? chexName("STYSNUM5") : chexName("STGNUM5"), (-49, -18), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			DrawImage(CPlayer.HasWeaponsInSlot(6)? chexName("STYSNUM6") : chexName("STGNUM6"), (-37, -18), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			DrawImage(CPlayer.HasWeaponsInSlot(7)? chexName("STYSNUM7") : chexName("STGNUM7"), (-25, -18), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
		}
		
		// Draw Mugshot/Inventory (Overwrite Mugshot)
		if(invReplace.getInt())
		{
			if (CPlayer.mo.InvSel != null && !Level.NoInventoryBar)
			{
				drawBerserk(alphaFloatGraph); // Draw Under Inventory
				DrawInventoryIcon(CPlayer.mo.InvSel, (0, -16), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_CENTER, alpha:alphaFloatGraph);
				if (CPlayer.mo.InvSel.Amount > 1)
				{
					DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (9, -2-mIndexFontF.mFont.GetHeight()), DI_SCREEN_CENTER_BOTTOM, Font.CR_GOLD, alpha:alphaFloatNum);
				}
			}
			else
			{
				DrawTexture(GetMugShot(5), (-17+isChex(1), -32), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
				drawBerserk(alphaFloatGraph); // Draw Over Mugshot
			}
		}
		// Draw Mugshot/Inventory (Do Not Overwrite Mugshot)
		else
		{
			DrawTexture(GetMugShot(5), (-17+isChex(1), -32), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
			drawBerserk(alphaFloatGraph); // Draw Over Mugshot
			if (CPlayer.mo.InvSel != null && !Level.NoInventoryBar)
			{
				DrawInventoryIcon(CPlayer.mo.InvSel, (180, -16), DI_SCREEN_CENTER_BOTTOM|DI_ITEM_CENTER, alpha:alphaFloatGraph);
				if (CPlayer.mo.InvSel.Amount > 1)
				{
					DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (189, -2-mIndexFontF.mFont.GetHeight()), DI_SCREEN_CENTER_BOTTOM, Font.CR_GOLD, alpha:alphaFloatNum);
				}
			}
		}
		
		// Draw Inventory Bar
		if (isInventoryBarVisible())
		{
			int itemCount = 0;
			for(Inventory item = CPlayer.mo.InvFirst; item != NULL && itemCount < 7; item = item.NextInv())
				itemCount++;
			DrawInventoryBarTrans(diparms_sbar, (0, -33), max(itemCount,1), DI_SCREEN_CENTER_BOTTOM, bgalpha:alphaFloat, fgalpha:alphaFloatGraph, numalpha:alphaFloatNum);
		}
	}
	
	void DrawSplit ()
	{
		double alphaFloat = 1-alphaValue.getfloat(); // Transparency
		
		int alphaO = alphaOpaque.GetInt();
		double alphaFloatNum = alphaO == OP_NUM || alphaO == OP_NUMGRAPH ? 1 : alphaFloat;
		double alphaFloatGraph = alphaO == OP_NUMGRAPH ? 1 : alphaFloat;
		
		// Draw left side
		DrawImage(addArms("HUD_LEFT"), (71.5, 0), DI_SCREEN_LEFT_BOTTOM, alphaFloat);
		if(multiplayer) DrawImage("STFBANY", (107, -32), DI_SCREEN_LEFT_BOTTOM|DI_TRANSLATABLE|DI_ITEM_OFFSETS, alphaFloat);

		// Draw right side
		DrawImage(addArms("HUD_RIGHT"), (-71.5, 0), DI_SCREEN_RIGHT_BOTTOM, alphaFloat);
		
		// Draw Percent Symbols
		int percentColor = GetPercentColor();
		DrawString(mHUDFont, "%", (90+isChex(1), -29), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_TOP|DI_NOSHADOW, translation: percentColor, alpha:alphaFloatNum);
		DrawString(mHUDFont, "%", (-99+isChex(2),-29), DI_SCREEN_RIGHT_BOTTOM|DI_ITEM_TOP|DI_NOSHADOW, translation: percentColor, alpha:alphaFloatNum);
	
		// Draw Current Ammo Counter
		Inventory a1 = GetCurrentAmmo();
		if (a1 != null)
		{
			int ammoColor = GetAmmoColor(a1);
			DrawString(mHUDFont, FormatNumber(a1.Amount, 3), (44+isChex(4), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_LEFT_BOTTOM, translation: ammoColor, alpha:alphaFloatNum);
		}
		
		// Draw Health
		int healthColor = GetHealthColor();
		DrawString(mHUDFont, FormatNumber(CPlayer.health, 3), (90+isChex(1), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_LEFT_BOTTOM, translation: healthColor, alpha:alphaFloatNum);
		
		// Draw Armor
		int armorColor = GetArmorColor();
		DrawString(mHUDFont, FormatNumber(GetArmorAmount(), 3), (-99+isChex(2), -29), DI_TEXT_ALIGN_RIGHT|DI_NOSHADOW|DI_SCREEN_RIGHT_BOTTOM, translation:armorColor, alpha:alphaFloatNum);

		// Draw Keys
		bool locks[6];
		String image;
		for(int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
		// key 1
		if (locks[1] && locks[4]) image = "STKEYS6";
		else if (locks[1]) image = "STKEYS0";
		else if (locks[4]) image = "STKEYS3";
		DrawImage(image, (-81, -29), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_RIGHT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
		// key 2
		if (locks[2] && locks[5]) image = "STKEYS7";
		else if (locks[2]) image = "STKEYS1";
		else if (locks[5]) image = "STKEYS4";
		else image = "";
		DrawImage(image, (-81, -19), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_RIGHT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
		// key 3
		if (locks[0] && locks[3]) image = "STKEYS8";
		else if (locks[0]) image = "STKEYS2";
		else if (locks[3]) image = "STKEYS5";
		else image = "";
		DrawImage(image, (-81, -9), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_RIGHT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);

		// Draw Total Ammo Count
		int amt1, maxamt;
		string ammonamesDoom[4] = {"Clip","Shell","RocketAmmo","Cell"};
		string ammonamesHacx[4] = {"HacxRounds","HacxCartridges","HacxTorpedo","HacxMolecules"};
		
		if(!chexArms || chexArms.getInt())
		{
			for(int i = 0; i < 4; i++)
			{
				for(int j = 0; j < AllActorClasses.Size(); j++)
				{
					if(AllActorClasses[j] is (!isHacx() ? ammonamesDoom[i] : ammonamesHacx[i]))
					{
						let ammotype = (class<Ammo>)(AllActorClasses[j]);
						[amt1, maxamt] = GetAmount(ammotype);
						DrawString(mIndexFontF, FormatNumber(amt1,   3), (-32+isChex(5), -27+6*i), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_RIGHT_BOTTOM, alpha:alphaFloatNum);
						DrawString(mIndexFontF, FormatNumber(maxamt, 3), (-6+isChex(1), -27+6*i), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_RIGHT_BOTTOM, alpha:alphaFloatNum);
						break;
					}			
				}
			}
		}
		
		// Draw Split Arms over face if CVAR is on
		if(splitArms.GetInt())
		{
			if(!isHacX())
			{
				DrawImage(CPlayer.HasWeaponsInSlot(2)? chexName("STYSNUM2") : chexName("STGNUM2"), (108+0*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(3)? chexName("STYSNUM3") : chexName("STGNUM3"), (108+1*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(4)? chexName("STYSNUM4") : chexName("STGNUM4"), (108+2*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(5)? chexName("STYSNUM5") : chexName("STGNUM5"), (108+3*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(6)? chexName("STYSNUM6") : chexName("STGNUM6"), (108+4*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(7)? chexName("STYSNUM7") : chexName("STGNUM7"), (108+5*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			}
			else // HacX font is backwards if not on the display
			{
				DrawImage(CPlayer.HasWeaponsInSlot(2)? chexName("STGNUM2") : chexName("STYSNUM2"), (108+0*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(3)? chexName("STGNUM3") : chexName("STYSNUM3"), (108+1*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(4)? chexName("STGNUM4") : chexName("STYSNUM4"), (108+2*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(5)? chexName("STGNUM5") : chexName("STYSNUM5"), (108+3*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(6)? chexName("STGNUM6") : chexName("STYSNUM6"), (108+4*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
				DrawImage(CPlayer.HasWeaponsInSlot(7)? chexName("STGNUM7") : chexName("STYSNUM7"), (108+5*6, -38), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatNum);
			}
		}
		
		
		// Draw Mugshot/Inventory (Overwrite Mugshot)
		if(invReplace.getInt())
		{
			if (CPlayer.mo.InvSel != null && !Level.NoInventoryBar)
			{
				drawBerserk(alphaFloatGraph,true); // Draw Under Inventory
				DrawInventoryIcon(CPlayer.mo.InvSel, (124, -16), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_CENTER, alpha:alphaFloatGraph);
				if (CPlayer.mo.InvSel.Amount > 1)
				{
					DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (133, -2-mIndexFontF.mFont.GetHeight()), DI_SCREEN_LEFT_BOTTOM, Font.CR_GOLD, alpha:alphaFloatNum);
				}
			}
			else
			{
				DrawTexture(GetMugShot(5), (107+isChex(1)+isHacX(1), -32), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
				drawBerserk(alphaFloatGraph,true); // Draw Over Mugshot
			}
		}
		// Draw Mugshot/Inventory (Do Not Overwrite Mugshot)
		else
		{
			DrawTexture(GetMugShot(5), (107+isChex(1)+isHacX(1), -32), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_OFFSETS, alphaFloatGraph);
			drawBerserk(alphaFloatGraph,true); // Draw Over Mugshot
			if (CPlayer.mo.InvSel != null && !Level.NoInventoryBar)
			{
				DrawInventoryIcon(CPlayer.mo.InvSel, (163, -16), DI_SCREEN_LEFT_BOTTOM|DI_ITEM_CENTER, alpha:alphaFloatGraph);
				if (CPlayer.mo.InvSel.Amount > 1)
				{
					DrawString(mAmountFont, FormatNumber(CPlayer.mo.InvSel.Amount), (172, -2-mIndexFontF.mFont.GetHeight()), DI_SCREEN_LEFT_BOTTOM, Font.CR_GOLD, alpha:alphaFloatNum);
				}
			}
		}

		// Draw Frags
		if (deathmatch || teamplay)
		{
			DrawString(mAmountFont, FormatNumber(CPlayer.FragCount, 3), (139, -30), DI_TEXT_ALIGN_RIGHT|DI_SCREEN_LEFT_BOTTOM|DI_NOSHADOW, Font.CR_RED, alpha:alphaFloatNum);
		}
		
		// Draw Inventory Bar
		if (isInventoryBarVisible())
		{
			int itemCount = 0;
			for(Inventory item = CPlayer.mo.InvFirst; item != NULL && itemCount < 4; item = item.NextInv())
				itemCount++;
			DrawInventoryBarTrans(diparms_sbar, (0, -1), max(itemCount,1), DI_SCREEN_CENTER_BOTTOM, bgalpha:alphaFloat, fgalpha:alphaFloatGraph, numalpha: alphaFloatNum);
		}
	}
	
	// =====================================================
	// The Main Functions for Drawing Stats
	// =====================================================
	void DrawStatLine(font fnt, int cr, Vector2 pos, String text, double alpha)
	{
		Vector2 scale = GetHUDScale();
		
		// These values are jury-rigged; they were initially designed for my personal settings before becoming generic
		int VirtualWidth  = floor(650 * 6.0/scale.x * Screen.GetWidth() /2560);
		int VirtualHeight = floor(400 * 7.2/scale.y * Screen.GetHeight()/1440);
		
		int posX = pos.x >= 0 ? pos.x : VirtualWidth  + pos.x;
		int posY = pos.y >= 0 ? pos.y : VirtualHeight + pos.y;

		screen.DrawText(fnt, cr, posX, posY, text, 
			DTA_KeepRatio, true,
			DTA_VirtualWidth, VirtualWidth, DTA_VirtualHeight, VirtualHeight, DTA_Alpha, alpha);
	}
	
	protected virtual void DrawLevelStats (Font fnt)
	{
		int alphaO = alphaOpaque.GetInt();
		double alphaFloat = alphaO == OP_NUM || alphaO == OP_NUMGRAPH ? 1 : 1-alphaValue.getfloat();
		
		int compColor;
		switch(statsCompColor.GetInt())
		{
			case GREEN:
				compColor = Font.CR_GREEN;
				break;
			case RED:
				compColor = Font.CR_RED;
				break;
			case NONE:
			default:
				compColor = Font.CR_WHITE;
				break;
		}
		
		string kills = "";
		string secrets = "";
		string items = "";
		string time = "";

		int mkilled   = multiplayer? CPlayer.killcount : Level.killed_monsters;
		int sfound    = multiplayer? CPlayer.secretcount : Level.found_secrets;
		int ifound    = multiplayer? CPlayer.itemcount : Level.found_items;
		
		// Format based on type specified
		string killstring = (gameinfo.gametype & GAME_Chex) ? "Zorches" : "Kills";
		switch(statsType.GetInt())
		{
			case PERCENT: // Take care of division by zero here
				if (statKills.GetInt())   kills   = string.format("%s: %i%%", killstring,Level.total_monsters ? 100*mkilled/Level.total_monsters : 100);
				if (statSecrets.GetInt()) secrets = string.format("Secrets: %i%%",Level.total_secrets ? 100*sfound/Level.total_secrets : 100);
				if (statItems.GetInt())   items   = string.format("Items: %i%%",  Level.total_items ? 100*ifound/Level.total_items : 100);
				break;
				
			case COUNTDOWN:
				if (statKills.GetInt())   kills   = string.format("%s: %i Left", killstring,Level.total_monsters - mkilled);
				if (statSecrets.GetInt()) secrets = string.format("Secrets: %i Left", Level.total_secrets - sfound);
				if (statItems.GetInt())   items   = string.format("Items: %i Left", Level.total_items - ifound);
				break;
				
			case FRACTION:
				if (statKills.GetInt())   kills   = string.format("%s: %i/%i",killstring,mkilled, Level.total_monsters);
				if (statSecrets.GetInt()) secrets = string.format("Secrets: %i/%i",sfound, Level.total_secrets);
				if (statItems.GetInt())   items   = string.format("Items: %i/%i",ifound, Level.total_items);
				break;
		}
		// Format Level time
		int hubtime = Level.time/Thinker.TICRATE;
		if (statTime.GetInt()) time = string.format("%02d:%02d:%02d",hubtime/3600,(hubtime/60)%60,hubtime%60);
		
		int textSize = fnt.GetHeight()*0.8;
		int killpos = statKills.getInt();
		int secretpos = statSecrets.getInt();
		int itempos = statItems.getInt();
		int timepos = statTime.getInt();
		
		// Make each block have the same length
		int maxlength[5] = {0,0,0,0,0};
		maxlength[killpos]   = max(maxlength[killpos],  kills.length());
		maxlength[secretpos] = max(maxlength[secretpos],secrets.length());
		maxlength[itempos]   = max(maxlength[itempos],  items.length());
		
		kills = makeLength(kills,maxlength[killpos]);
		secrets = makeLength(secrets,maxlength[secretpos]);
		items = makeLength(items,maxlength[itempos]);
		
		// Top Left
		int topLeftTotal = 0;
		if(killpos   == TOPLEFT) DrawStatLine(fnt,mkilled == Level.total_monsters ? compColor : Font.CR_WHITE, (2,textSize*topLeftTotal++) ,kills,alphaFloat);
		if(secretpos == TOPLEFT) DrawStatLine(fnt,sfound == Level.total_secrets   ? compColor : Font.CR_WHITE, (2,textSize*topLeftTotal++) ,secrets,alphaFloat);
		if(itempos   == TOPLEFT) DrawStatLine(fnt,ifound == Level.total_items     ? compColor : Font.CR_WHITE, (2,textSize*topLeftTotal++) ,items,alphaFloat);
		if(timepos   == TOPLEFT && statsType.GetInt() != 0) DrawStatLine(fnt,                            Font.CR_WHITE, (2,textSize*topLeftTotal++) ,time,alphaFloat);
		// Top Right
		// This needs special handling for vid_fps
		int conOffset = vid_fps ?  GetConSize()+2 : 0;
		int topRightTotal = 0;
		if(killpos   == TOPRIGHT) DrawStatLine(fnt,mkilled == Level.total_monsters ? compColor : Font.CR_WHITE, (-fnt.StringWidth(kills),  conOffset+textSize*topRightTotal++)  ,kills,alphaFloat);
		if(secretpos == TOPRIGHT) DrawStatLine(fnt,sfound == Level.total_secrets   ? compColor : Font.CR_WHITE, (-fnt.StringWidth(secrets),conOffset+textSize*topRightTotal++),secrets,alphaFloat);
		if(itempos   == TOPRIGHT) DrawStatLine(fnt,ifound == Level.total_items     ? compColor : Font.CR_WHITE, (-fnt.StringWidth(items),  conOffset+textSize*topRightTotal++)  ,items,alphaFloat);
		if(timepos   == TOPRIGHT && statsType.GetInt() != 0) DrawStatLine(fnt,                            Font.CR_WHITE, (-fnt.StringWidth(time),   conOffset+textSize*topRightTotal++)   ,time,alphaFloat);
		// Bottom Left
		int bottomLeftTotal = 0;
		if(itempos   == BOTTOMLEFT) DrawStatLine(fnt,ifound == Level.total_items     ? compColor : Font.CR_WHITE, (2,-78-textSize*bottomLeftTotal++) ,items,alphaFloat);
		if(secretpos == BOTTOMLEFT) DrawStatLine(fnt,sfound == Level.total_secrets   ? compColor : Font.CR_WHITE, (2,-78-textSize*bottomLeftTotal++) ,secrets,alphaFloat);
		if(killpos   == BOTTOMLEFT) DrawStatLine(fnt,mkilled == Level.total_monsters ? compColor : Font.CR_WHITE, (2,-78-textSize*bottomLeftTotal++) ,kills,alphaFloat);
		if(timepos   == BOTTOMLEFT && statsType.GetInt() != 0) DrawStatLine(fnt,                           Font.CR_WHITE, (2,-78-textSize*bottomLeftTotal++) ,time,alphaFloat);
		// Bottom Right
		int bottomRightTotal = 0;
		if(secretpos == BOTTOMRIGHT) DrawStatLine(fnt,sfound == Level.total_secrets   ? compColor : Font.CR_WHITE, (-fnt.StringWidth(secrets),-78-textSize*bottomRightTotal++),secrets,alphaFloat);
		if(itempos   == BOTTOMRIGHT) DrawStatLine(fnt,ifound == Level.total_items     ? compColor : Font.CR_WHITE, (-fnt.StringWidth(items),  -78-textSize*bottomRightTotal++)  ,items,alphaFloat);
		if(killpos   == BOTTOMRIGHT) DrawStatLine(fnt,mkilled == Level.total_monsters ? compColor : Font.CR_WHITE, (-fnt.StringWidth(kills),  -78-textSize*bottomRightTotal++)  ,kills,alphaFloat);
		if(timepos   == BOTTOMRIGHT && statsType.GetInt() != 0) DrawStatLine(fnt,   			    Font.CR_WHITE, (-fnt.StringWidth(time),   -78-textSize*bottomRightTotal++)   ,time,alphaFloat);
	}
	
	// ================================================
	// Helper Functions for getting various font colors
	// ================================================
	int GetPercentColor()
	{
		return boomColors.getInt() ? Font.CR_WHITE : Font.CR_UNTRANSLATED;
	}
	
	int GetAmmoColor(Inventory a1)
	{
		int amt1   = a1.Amount;
		int maxamt = a1.MaxAmount;
		
		int ammoColor;
		if(boomColors.getInt())
		{
			if		(amt1 <= maxamt/4) ammoColor = FONT.CR_RED;
			else if (amt1 <= maxamt/2) ammoColor = FONT.CR_YELLOW;
			else 					   ammoColor = FONT.CR_GREEN;
		}
		else
			ammoColor = FONT.CR_UNTRANSLATED;
			
		return ammoColor;
	}
	
	int GetHealthColor()
	{
		int currHealth = CPlayer.Health;
		int maxHealth = CPlayer.mo.GetMaxHealth();
		
		int healthColor;
		if(boomColors.getInt())
		{
			if 	(currHealth <= maxHealth/4) healthColor = FONT.CR_RED;
			else if	(currHealth <= maxHealth/2) healthColor = FONT.CR_YELLOW;
			else if	(currHealth <= maxHealth)   healthColor = FONT.CR_GREEN;
			else 				    healthColor = isChex() ? FONT.CR_LIGHTBLUE : FONT.CR_BLUE;
		}
		else
			healthColor = FONT.CR_UNTRANSLATED;
			
		return healthColor;	
	}
	
	int GetArmorColor()
	{
		int currArmor = GetArmorSavePercent();
		
		int armorColor;
		if(boomColors.getInt())
		{
			if		(currArmor >= gameinfo.Armor2Percent*100) armorColor = isChex() ? FONT.CR_LIGHTBLUE : FONT.CR_BLUE;
			else if (currArmor > 0)							  armorColor = FONT.CR_GREEN;
			else											  armorColor = FONT.CR_RED;
		}
		else
			armorColor = FONT.CR_UNTRANSLATED;
			
		return armorColor;
	}
	
	// ===================================
	// Helper Function to get vid_fps size
	// ===================================
	int GetConSize()
	{
		int scaleval;
		if (con_scale > 0) scaleval = (con_scale+1) / 2;
		else if (uiscale == 0)
		{
			// Default should try to scale to 640x400
			int vscale = screen.GetHeight() / 800;
			int hscale = screen.GetWidth() / 1280;
			scaleval = clamp(vscale, 1, hscale);
		}
		else scaleval = (uiscale+1) / 2;

		// block scales that result in something larger than the current screen.
		int vmax = screen.GetHeight() / 400;
		int hmax = screen.GetWidth() / 640;
		int max = MAX(vmax, hmax);
		return NewConsoleFont.GetHeight()*MAX(1, MIN(scaleval, max))/4;
	}
	
	// ================================================
	// Helper Function to make string a specific length
	// ================================================
	String makeLength(string input, int length, string extender = ":")
	{
		if(input.length() > length) return input;
		
		string replacer = string.format(string.format("%%s%%%ds",length-input.length()), extender, "");
		input.replace(extender,replacer);
		return input;
	}
	
	// =================================
	// Draw Berserk Symbol if CVAR is on
	// =================================
	void drawBerserk(float alphaFloat, bool split = 0)
	{
		if(berserkShow.GetInt() && CPlayer.mo.FindInventory("PowerStrength"))
		{
			DrawImage("BERSERK", (split ? 138-isHacX(1)-isFreeDoom(3) : 14-isHacX(2)-isFreeDoom(3), -1), split ? DI_SCREEN_LEFT_BOTTOM : DI_SCREEN_CENTER_BOTTOM, alphaFloat);
		}
	}

	// ===================================
	// Wrapper to add offsets for Freedoom
	// ===================================
	float isFreeDoom(float offset = 1.0)
	{
		if(Wads.CheckNumForName("FREEDOOM",0)!=-1)
			return offset;
		return 0;
	}
	
	// =====================================
	// Wrapper to add offsets for Chex Quest
	// =====================================
	float isChex(float offset = 1.0)
	{
		return gameinfo.gametype & GAME_Chex ? offset : 0;
	}
	
	// =======================
	// Add arms for Chex Quest
	// =======================
	string addArms(string input)
	{
		string output = string.format("%s%s", input, chexArms && chexArms.GetInt() ? "_ARMS" : "");
		return output;
	}
	
	// If Chex, change arms to match chexfont (this allows the normal HUD to work)
	string chexName(string input)
	{
		if(isChex())
		{
			input.replace("STY","CTY");
			input.replace("STG","CTG");
		}
		return input;
	}
	
	// ===============================
	// Wrapper to add offsets for HacX
	// ===============================
	float isHacX(float offset = 1.0)
	{
		if(Wads.CheckNumForName("HACX-R",0)!=-1 || Wads.CheckNumForName("HACX-E",0)!=-1)
			return offset;
		return 0;
	}
	
	// ================================================
	// Override to ensure HacX standard HUD still works
	// ================================================
	override void DrawBarAmmo()
	{
		if ( !isHacX() )
			Super.DrawBarAmmo();
		else
		{
			int amt1, maxamt;
			// We must store the ammo types in a string, because using them directly 
			// will prevent GZDoom from starting because it tries to resolve the names
			// at launch instead of during runtime
			string ammoClass; 
			
			ammoClass = "HacxRounds";
			[amt1, maxamt] = GetAmount(ammoClass);
			DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 173), DI_TEXT_ALIGN_RIGHT);
			DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 173), DI_TEXT_ALIGN_RIGHT);
			
			ammoClass = "HacxCartridges";
			[amt1, maxamt] = GetAmount(ammoClass);
			DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 179), DI_TEXT_ALIGN_RIGHT);
			DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 179), DI_TEXT_ALIGN_RIGHT);
			
			ammoClass = "HacxTorpedo";
			[amt1, maxamt] = GetAmount(ammoClass);
			DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 185), DI_TEXT_ALIGN_RIGHT);
			DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 185), DI_TEXT_ALIGN_RIGHT);
			
			ammoClass = "HacxMolecules";
			[amt1, maxamt] = GetAmount(ammoClass);
			DrawString(mIndexFont, FormatNumber(amt1, 3), (288, 191), DI_TEXT_ALIGN_RIGHT);
			DrawString(mIndexFont, FormatNumber(maxamt, 3), (314, 191), DI_TEXT_ALIGN_RIGHT);
		}
	}

	// =========================================================
	// Same as DrawInventoryBar, but with transparency for items
	// =========================================================
	void DrawInventoryBarTrans(InventoryBarState parms, Vector2 position, int numfields, int flags = 0, double bgalpha = 1., double fgalpha = 1., double numalpha = 1.)
	{
		double width = parms.boxsize.X * numfields;
		[position, flags] = AdjustPosition(position, flags, width, parms.boxsize.Y);
		
		CPlayer.mo.InvFirst = ValidateInvFirst(numfields);
		if (CPlayer.mo.InvFirst == null) return;	// Player has no listed inventory items.
		
		Vector2 boxsize = parms.boxsize;
		// First draw all the boxes
		for(int i = 0; i < numfields; i++)
		{
			DrawTexture(parms.box, position + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, bgalpha);
		}
		
		// now the items and the rest
		
		Vector2 itempos = position + boxsize / 2;
		Vector2 textpos = position + boxsize - (1, 1 + parms.amountfont.mFont.GetHeight());

		int i = 0;
		Inventory item;
		for(item = CPlayer.mo.InvFirst; item != NULL && i < numfields; item = item.NextInv())
		{
			for(int j = 0; j < 2; j++)
			{
				if (j ^ !!(flags & DI_DRAWCURSORFIRST))
				{
					if (item == CPlayer.mo.InvSel)
					{
						double flashAlpha = fgalpha;
						if (flags & DI_ARTIFLASH) flashAlpha *= itemflashFade;
						DrawTexture(parms.selector, position + parms.selectofs + (boxsize.X * i, 0), flags | DI_ITEM_LEFT_TOP, flashAlpha);
					}
				}
				else
				{
					DrawInventoryIcon(item, itempos + (boxsize.X * i, 0), flags | DI_ITEM_CENTER, fgalpha );
				}
			}
			
			if (parms.amountfont != null && (item.Amount > 1 || (flags & DI_ALWAYSSHOWCOUNTERS)))
			{
				DrawString(parms.amountfont, FormatNumber(item.Amount, 0, 5), textpos + (boxsize.X * i, 0), flags | DI_TEXT_ALIGN_RIGHT, parms.cr, numalpha);
			}
			i++;
		}
		// Is there something to the left?
		if (CPlayer.mo.FirstInv() != CPlayer.mo.InvFirst)
		{
			DrawTexture(parms.left, position + (-parms.arrowoffset.X, parms.arrowoffset.Y), flags | DI_ITEM_RIGHT|DI_ITEM_VCENTER, fgalpha);
		}
		// Is there something to the right?
		if (item != NULL)
		{
			DrawTexture(parms.right, position + parms.arrowoffset + (width, 0), flags | DI_ITEM_LEFT|DI_ITEM_VCENTER, fgalpha);
		}
	}
}